​	Channel主要做的事情就是封装了fd、events、revents，还有一组回调函数。fd就表示要往poller上注册的文件描述符，events表示fd一开始设置的感兴趣的事件（读、写、错误事件），revents表示最终poller通知的fd上真正发生的事件，根据相应的事件来执行相应的回调。对于上层来说，如果有一个fd的话就会把fd打包成channel从而下发到poller上
​	poller有一个成员变量channels_，是一个map，键就是channel打包的文件描述符fd，值对应的就是包含这个fd的channel，也就是说如果poller检测到哪个fd有时间发生了，然后它就可以通过发生事件的fd，对照这个map表来找到对应的channel，然后执行相应的回调函数。这个channel里就记录了详细的发生事件的回调函数，channel和poller是独立的，两者不能直接通信，是依赖于eventloop来通信的
​	muduo库不管是监听用的listenfd还是跟客户端连接成功于客户端通信的connfd，都会把fd打包成channel，然后注册到对应loop的poller上去，channel的回调函数也是上层设置的，整个muduo库中总共有两种channel，对应着两种fd：acceptorchannel对应listenfd，connectionchannel对应connfd
​	EventLoop相当于Reactor组件，Poller相当于Demultiplex组件，EventLoop类中有成员变量activeChannels，这里面包含了所有的channel。还有wakeupfd和wakeupchannel，这两者的作用是一个wakeupfd隶属于一个loop，因为loop最终执行的时候是驱动底层的epoll_wait函数，只要没有事件发生就会一直处于阻塞状态，如果要唤醒某一个loop的阻塞状态的话，那么直接通过loop对象获取其wakeupfd，往wakeupfd上去写一个数据，相应的loop就会被唤醒，因为每一个loop的wakeupfd也被封装成一个wakeupchannel注册在了自己loop上的底层的epoll上；还有一个成员变量就是poller，eventloop管理的就是一堆的channel和一个poller，还有一个wakeupfd
​	channel通过eventloop获取poller对象来向poller中注册fd和事件，同样的poller检测到相应的事件发生，然后通过eventloop调用channel相应的fd所发生事件的回调函数，channel、poller、eventloop三者是紧密相连的
​	EventLoop::pendingFunctors中存放了一堆的回调函数，因为每一个回调在执行的时候都应该处于loop自己所处的线程去执行，如果说当前线程就是对应了当前loop，则直接执行回调，否则就存放在pendingFunctors然后唤醒相应的loop去pendingFunctors拿取相应的回调函数去执行
​	EventLoopThreadPool::getNextLoop通过轮询算法获取下一个subloop，如果没有创建过subloop，那么getNextLoop返回的永远都是baseloop，当通过setThreadNumber设置底层线程数量的时候EventLoopThreadPool就会驱动底层创建线程，一个Thread对应一个loop（one loop per thread），EventLoopThread包含了底层的一个线程成员变量Thread，EventLoopThread::startloop开启一个新线程，EventLoopThread::threadFunc就是线程函数，在线程函数中创建了一个Eventloop并且通过loop.loop()开启当前线程的事件循环
​	









